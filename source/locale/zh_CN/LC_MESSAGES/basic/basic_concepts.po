# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Megvii
# This file is distributed under the same license as the MegEngine Documents
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MegEngine Documents \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-17 15:24+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/basic/basic_concepts.rst:4
msgid "基本概念"
msgstr ""

#: ../../source/basic/basic_concepts.rst:6
msgid "MegEngine 是基于计算图的深度神经网络学习框架。 本节内容会简要介绍计算图及其相关基本概念，以及它们在 MegEngine 中的实现。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:10
msgid "计算图（Computation Graph）"
msgstr ""

#: ../../source/basic/basic_concepts.rst:12
msgid "我们通过一个简单的数学表达式 :math:`y = (w * x) + b` 来介绍计算图的基本概念，如下图所示："
msgstr ""

#: ../../source/basic/basic_concepts.rst:18
msgid "图1"
msgstr ""

#: ../../source/basic/basic_concepts.rst:20
msgid "从中我们可以看到，计算图中存在："
msgstr ""

#: ../../source/basic/basic_concepts.rst:22
msgid ""
"数据节点（图中的实心圈）：如输入数据 :math:`x` 、 :math:`w` 、 :math:`b` ，运算得到的中间数据 :math:`p`"
" ，以及最终的运算输出 :math:`y` ；"
msgstr ""

#: ../../source/basic/basic_concepts.rst:23
msgid "计算节点（图中的空心圈）：图中 * 和 + 分别表示计算节点 **乘法** 和 **加法**，是施加在数据节点上的运算；"
msgstr ""

#: ../../source/basic/basic_concepts.rst:24
msgid "边（图中的箭头）：表示数据的流向，体现了数据节点和计算节点之间的依赖关系；"
msgstr ""

#: ../../source/basic/basic_concepts.rst:26
msgid ""
"如上，便是一个简单的计算图示例。计算图是一个包含数据节点和计算节点的有向图（可以是有环的，也可以是无环的）， "
"是数学表达式的形象化表示。在深度学习领域，任何复杂的深度神经网络本质上都可以用一个计算图表示出来。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:29
msgid ""
"**前向传播** 是计算由计算图表示的数学表达式的值的过程。在图1中，变量 :math:`x` 和 :math:`w` "
"，从左侧输入，首先经过乘法运算得到中间结果 :math:`p` ， 接着，:math:`p` 和输入变量 :math:`b` "
"经过加法运算，得到右侧最终的输出 :math:`y` ，这就是一个完整的前向传播过程。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:32
msgid "在 MegEngine 中，我们用张量（Tensor）表示计算图中的数据节点，以及用算子（Operator）实现数据节点之间的运算。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:35
msgid "张量（Tensor）"
msgstr ""

#: ../../source/basic/basic_concepts.rst:37
msgid ""
"与 PyTorch，TensorFlow 等深度学习框架类似，MegEngine 使用张量（Tensor）来表示计算图中的数据。 "
"张量（Tensor）可以看做 NumPy 中的数组，它可以是标量、向量、矩阵或者多维数组。 我们可以通过 NumPy 或者 Python List"
" 来创建一个 Tensor 。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:55
msgid "输出:"
msgstr ""

#: ../../source/basic/basic_concepts.rst:64
msgid "我们可以通过 :meth:`~.Tensor.set_value` 来更改 Tensor 的值。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:75
#: ../../source/basic/basic_concepts.rst:92
#: ../../source/basic/basic_concepts.rst:122
#: ../../source/basic/basic_concepts.rst:150
#: ../../source/basic/basic_concepts.rst:170
#: ../../source/basic/basic_concepts.rst:182
#: ../../source/basic/basic_concepts.rst:200
#: ../../source/basic/basic_concepts.rst:222
#: ../../source/basic/basic_concepts.rst:248
#: ../../source/basic/basic_concepts.rst:263
#: ../../source/basic/basic_concepts.rst:312
msgid "输出："
msgstr ""

#: ../../source/basic/basic_concepts.rst:83
msgid ""
"通过 :meth:`dtype <.Tensor.dtype>` 属性我们可以获取 Tensor 的数据类型； 通过 "
":meth:`~.Tensor.astype` 方法我们可以拷贝创建一个指定数据类型的新 Tensor ，原 Tensor 不变。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:99
msgid "通过 :meth:`shape <.Tensor.shape>` 属性，我们可以获取 Tensor 的形状："
msgstr ""

#: ../../source/basic/basic_concepts.rst:105
msgid "输出为一个Tuple："
msgstr ""

#: ../../source/basic/basic_concepts.rst:112
msgid "通过 :meth:`~.Tensor.numpy` 方法，我们可以将 Tensor 转换为 numpy.ndarray："
msgstr ""

#: ../../source/basic/basic_concepts.rst:134
msgid "算子（Operator）"
msgstr ""

#: ../../source/basic/basic_concepts.rst:136
msgid ""
"MegEngine 中通过算子 (Operator） 来表示运算。 类似于 NumPy，MegEngine 中的算子支持基于 Tensor "
"的常见数学运算和操作。 下面介绍几个简单示例："
msgstr ""

#: ../../source/basic/basic_concepts.rst:140
msgid "Tensor 的加法："
msgstr ""

#: ../../source/basic/basic_concepts.rst:164
msgid "Tensor 的切片："
msgstr ""

#: ../../source/basic/basic_concepts.rst:176
msgid "Tensor 形状的更改："
msgstr ""

#: ../../source/basic/basic_concepts.rst:192
msgid ":meth:`~.Tensor.reshape` 的参数允许存在单个维度的缺省值，用 -1 表示。此时，reshape 会自动推理该维度的值："
msgstr ""

#: ../../source/basic/basic_concepts.rst:207
msgid "MegEngine 的 :mod:`~.megengine.functional` 提供了更多的算子，比如深度学习中常用的矩阵乘操作、卷积操作等。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:209
msgid "Tensor 的矩阵乘："
msgstr ""

#: ../../source/basic/basic_concepts.rst:236
msgid "更多算子可以参见 :mod:`~.megengine.functional` 部分的文档。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:239
msgid "不同设备上的 Tensor"
msgstr ""

#: ../../source/basic/basic_concepts.rst:241
msgid ""
"创建的Tensor可以位于不同device，这根据当前的环境决定。 通过 :meth:`device <.Tensor.device>` "
"属性查询当前 Tensor 所在的设备。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:255
msgid ""
"通过 :meth:`~.Tensor.to` 可以在另一个 device 上生成当前 Tensor 的拷贝，比如我们将刚刚在 GPU 上创建的 "
"Tensor ``a`` 迁移到 CPU 上："
msgstr ""

#: ../../source/basic/basic_concepts.rst:271
msgid "反向传播和自动求导"
msgstr ""

#: ../../source/basic/basic_concepts.rst:273
msgid ""
"**反向传播** "
"神经网络的优化通常通过随机梯度下降来进行。我们需要根据计算图的输出，通过链式求导法则，对所有的中间数据节点求梯度，这一过程被称之为 “反向传播”。"
" 例如，我们希望得到图1中输出 :math:`y` 关于输入 :math:`w` 的梯度，那么反向传播的过程如下图所示："
msgstr ""

#: ../../source/basic/basic_concepts.rst:280
msgid "图2"
msgstr ""

#: ../../source/basic/basic_concepts.rst:282
msgid ""
"首先 :math:`y = p + b` ，因此 :math:`\\partial y / \\partial p = 1` ； "
"接着，反向追溯，:math:`p = w * x` ，因此，:math:`\\partial p / \\partial w = x` 。 "
"根据链式求导法则，:math:`\\partial y / \\partial w = (\\partial y / \\partial p) *"
" (\\partial p / \\partial w)` ， 因此最终 :math:`y` 关于输入 :math:`w` 的梯度为 "
":math:`x` 。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:287
msgid ""
"**自动求导** MegEngine 为计算图中的张量提供了自动求导功能，以上图的例子说明： 我们假设图中的 :math:`x` 是 shape "
"为 (1, 3) 的张量， :math:`w` 是 shape 为 (3, 1) 的张量， :math:`b` 是一个标量。 "
"利用MegEngine 计算 :math:`y = x * w + b` 的过程如下："
msgstr ""

#: ../../source/basic/basic_concepts.rst:302
msgid ""
"我们可以直接调用 :func:`~.graph.grad` 方法来计算输出 :math:`y` 关于 :math:`w` "
"的偏导数：:math:`\\partial y  / \\partial w` 。"
msgstr ""

#: ../../source/basic/basic_concepts.rst:320
msgid "可以看到，求出的梯度本身也是 Tensor。"
msgstr ""

